%version of 08-27-20

\chapter{Recurrences:
Rendering Complex Structure Manageable}
\label{ch:Recurrences}

\hfill
\begin{tabular}{l}
{\em Those who do not learn from history are doomed to repeat it.} \\
\hfill {\small George Santayana}
\end{tabular}

\index{Santayana, George}

\vspace*{.5in}

\noindent
One of the intellectually most powerful strategies for all manner of human endeavor is to ``learn from the past''---i.e., to {\em re}-use knowledge that one has acquired earlier in order to acquire new knowledge.  Within the domain of computing, this strategy is exemplified by computations that derive the value of a function $f$ at an argument $n \in \N^+$ by invoking the values of $f$ at arguments $1, 2, \ldots, n-1$.

\smallskip

\index{arithmetic!basic operations!factorial (of a nonnegative integer)}
The classical first example of such a {\it recurrent} mode of computing involves the {\it factorial function}, which is referred to as ``{\sc Fact}" Section~\ref{sec:factorial-function}.  The ``direct'' mode of computing {\sc Fact} at an argument $n \in \N^+$ is:
\[ \mbox{\sc Fact}(n) \ = \ 1 \times 2 \times 3 \times \cdots \times n \]
The {\em recurrent} mode of computing {\sc Fact}($n$) is more compact---and it better exposes the inherent structure of the function.
\[ \mbox{\sc Fact}(n) \ = \ \left\{
\begin{array}{cl}
 n \times \mbox{\sc Fact}(n-1) & \mbox{ if } \ n > 1 \\
 1 & \mbox{ if } \ n = 1 \\
\end{array}
\right.
\]

\smallskip

This chapter is devoted to deriving and solving a variety of types of recurrences.  In common with the rest of this text, our treatment of this subject emphasizes exploiting recurrent structure in reasoning and analysis: Increased understanding will enable improved computing.


\section{Linear Recurrences}
\label{sec:linear-recurrences}
\index{linear recurrences}

The first family of recurrences that we study are the {\em linear} recurrences, as exemplified by the following function specifications, wherein we have four integers: $a$, $b$, $c$, and $d$, with $a>1$ and $b>1$.

\begin{eqnarray}
\nonumber
\mbox{\bf The general form} & & \\
\label{eq:Lin-Recur:general}
f(n) & = & \left\{
\begin{array}{cl}
a f(n/b) + g(n) & \hspace*{.2in} \mbox{for } n \geq b \\
                    d & \hspace*{.2in} \mbox{for } n < b
\end{array}
\right. \\
\nonumber
  & & \\
\nonumber
\mbox{\bf The simple form} & & \\
\label{eq:Lin-Recur:basic}
f(n) & = & \left\{
\begin{array}{cl}
a f(n/b) + c & \hspace*{.4in} \mbox{for } n \geq b \\
               1 & \hspace*{.4in} \mbox{for } n < b
\end{array}
\right.
\end{eqnarray}


\smallskip

Many basic algorithmic problems, including sorting, selection, matching, \ldots can be solved using linear-recurrent algorithms \cite{CLRS}---and such algorithms yield to specification and analysis via linear recurrences.

\smallskip

In the next two subsections, we analyze recurrences (\ref{eq:Lin-Recur:general}) and (\ref{eq:Lin-Recur:basic}).  The techniques that we use in our analyses can be adapted to analyze other members of the important family of linear-recurrent algorithms.


\subsection{The Master Theorem for Simple Linear Recurrences} 
\label{sec:masterTheorem}
\label{sec:linear-recurrence-basic}

We focus first on the simpler of our sample recurrences, namely, (\ref{eq:Lin-Recur:basic}).  Happily, there is a single perspicuous proof that elegantly solves recurrences of this form.

\medskip

By the time the reader has reached this paragraph, she has the mathematical tools necessary to prove and apply what is called {\it The Master Theorem for Linear Recurrences} \cite{CLRS}.  The main tools we use to prove the Theorem are: summing geometric summations (Section~\ref{sec:geometric-sums}) and employing elementary asymptotic notions and notations (Section~\ref{sec:asymptotics}).

\index{Master Theorem!for the simple linear recurrence}
\begin{theorem}[The Master Theorem for the simple linear recurrence]
\label{thm:master-thm-simple}
Let the function $f$ be specified by the simple linear recurrence (\ref{eq:Lin-Recur:basic}).  The value of $f$ on any argument $n$ is given by
\begin{equation}
\label{eq:Lin-Recur:solve}
\begin{array}{lcllll}
f(n) & = & (1 + \log_b n) \cdot c &  &  & \mbox{if } a=1 \\
      &    &                 &  &  & \\
      & = &
  {\displaystyle
  \frac{1-a^{\log_b n}}{1-a} \cdot c \ \ \approx \ \ \frac{c}{1-a}
  }
                               &  &  & \mbox{if } a<1 \\
    &   &                   &  &  & \\
    & = &
  {\displaystyle
\frac{a^{\log_b n} -1}{a-1} \cdot c
  }
                             &  &  & \mbox{if } a>1
\end{array}
\end{equation}
\end{theorem}

\begin{proof}
We expose the pattern generated by recurrence (\ref{eq:Lin-Recur:basic}), by beginning to ``expand'' the specified computation---replacing occurrences of $f(\circ)$ as mandated in recurrence (\ref{eq:Lin-Recur:basic}).  Once we discern the pattern, we jump to the general form.
\begin{equation}
\label{eq:Lin-Recur:expand}
\begin{array}{lcccc}
f(n) & = & a f(n/b) + c & & \\
     & = & a \left( a f(n/b^2) + c \right) + c
             & = & a^2 f(n/b^2) + (a+1)c \\
     & = & a^2 \left( a f(n/b^3) + c \right) + (a+1)c
             & = & a^3 f(n/b^3) + (a^2+a+1)c \\
     &   & \vdots & & \vdots \\
     & = & 
{\displaystyle
\left(a^{\log_b n} + \cdots +a^2+a+1 \right) c
} & &
\end{array}
\end{equation}
The segment of recurrence (\ref{eq:Lin-Recur:expand}) that is ``hidden behind" the vertical dots betokens an induction that is left to the reader.  Eqs.~(\ref{eq:geom-sum:b>1}) and (\ref{eq:geom-sum:b<1}) now enable us to demonstrate that Eq.~(\ref{eq:Lin-Recur:solve}) is the asserted case-structured solution to (\ref{eq:Lin-Recur:basic}).  \qed
\end{proof}


\subsection{The Master Theorem for General Linear Recurrences} 
\label{sec:linear-recurrence-general}

We now progress from the simple recurrence (\ref{eq:Lin-Recur:basic}) to the more general recurrence (\ref{eq:Lin-Recur:general}).  We simplify our problem in three ways, to avoid calculational complications (such as floors and ceilings) that can mask the principles that govern
our analysis.
\begin{enumerate}
\item
We employ a very simple nonrecurrent function $g$: We focus on the case $g(n) = n$.

\smallskip

It requires only clerical effort to generalize to the slightly more ambitious function $g(n) = \alpha n + \beta$ (so that $g$ is a general {\em linear} function), but such an extension teaches no new lessons.
\medskip\item
We assume that the argument $n$ to functions $f$ and $g$ is a power of $b$.

\smallskip

This allows us to concentrate on the general unfolding of the recurrence without worrying about floors and ceilings.

\medskip\item
We consider only the value $c=1$.
\end{enumerate}
Removing these assumptions would significantly complicate our calculations, but it would not change our reasoning.

\index{Master Theorem!for the general linear recurrence}
\begin{theorem}[The Master Theorem for the general linear recurrence]
\label{thm:master-thm-genl}
Let the function $f$ be specified by the general linear recurrence (\ref{eq:Lin-Recur:general}). The value of $f$ on any argument $n$ is given by
\[
f(n) \ = \ 
a^{\log_b n} f(1) \ \ + \ \ \left( \sum_{i=0}^{\log_b (n)-1} (a/b)^i \right) n
\]

\smallskip

\noindent
When $a > b$, the behavior of $f(n)$ is dominated by the first term of this solution:
\[ a^{\log_b n} \cdot  f(1) \ \ = \ \ n^{\log_b a} \]

\smallskip

\noindent
When $a < b$, the behavior of $f(n)$ is dominated by the second term of this solution:
\[
n \cdot \sum_{i=0}^{\log_b (n)-1} (a/b)^i
  \ \ = \ \
\frac{\left( 1 \ - \  (a/b)^{\log_b (n)} \right)}{1- (a/b)} \cdot n \ \
  \ \ \approx \ \
\frac{b}{b - a} \cdot n
\]
\end{theorem}

\begin{proof}
As in Section~\ref{sec:linear-recurrence-basic}, we expose the algebraic pattern created by the recurrence by ``unfolding'' recurrence (\ref{eq:Lin-Recur:general}).  As in recurrence (\ref{eq:Lin-Recur:expand}), once we discern this pattern, we jump to the general form (which can be verified via induction).
\[
\begin{array}{ccccc}
f(n) & = & a f(n/b) + n & & \\
     & = & a \left( a f(n/b^2) + n/b \right) + n
             & = & a^2 f(n/b^2) + (an/b+n) \\
     & = & a^2 \left( a f(n/b^3) + n/b^2 \right) + (a/b+1)n
             & = & a^3 f(n/b^3) + (a^2/b^2+a/b+1)n \\
     &   & \vdots & & \vdots \\
    & = & 
{\displaystyle
a^{\log_b n} f(1) + \left( \sum_{i=0}^{\log_b (n)-1} (a/b)^i \right) n
} & &
\end{array}
\]

\smallskip

We thus see that solving the more general recurrence (\ref{eq:Lin-Recur:general}) requires only augmenting the solution to the simple recurrence (\ref{eq:Lin-Recur:basic}) by ``appending'' to
the simple solution a geometric summation whose base is the ratio $a/b$.  The reader can now invoke the techniques from Section~\ref{sec:summing-geometric-series:techniques} to arrive at the announced solution to recurrence (\ref{eq:Lin-Recur:general}).

\medskip

When one ``does'' mathematics, one is often interested in uncovering the {\em dominant behavior} of the function $f(n)$ specified via a recurrence such as (\ref{eq:Lin-Recur:general}).  Therefore, the two assertions in the statement of the proposition about the ``dominant behavior" of function $f$ for given relative sizes of $a$ and $b$ is an integral part of the lessons that we learn from this proof.

\medskip

One can learn yet other lessons about $f(n)$, specifically about how to compute $f(n)$ (exactly or approximately), by studying Fig.~\ref{fig:masterTheorem}.
\begin{figure}[htb]
\begin{center}
       \includegraphics[scale=0.4]{FiguresMaths/MasterTheoremgeneral}
\caption{Illustrating the calculation specified by recurrence (\ref{eq:Lin-Recur:general}).  The total cost is obtained by the summation on each row: $a \times f(n/b)$ in the first row, $a^2 \times f(n/b^2)$ in the second row, and so on.  This leads to the final value $a^{log_b(n)}$
\label{fig:masterTheorem}}
\end{center}
\end{figure}
In particular, one observes in the figure that when $a=b$, the computations in each row are perfectly balanced.  When $a=b=2$, for instance, the tree has $n$ leaves, and the computations inside the tree evaluate to exactly $n$ at each of the tree's $ \ln(n)$ levels---so that $f(n) = n \ln(n)$ in this case.  \qed
\end{proof}


\subsection{An Application: The Elements of Information Theory}
\label{sec:count-strings}

\index{Shannon, Claude E.} \index{Information Theory}
\index{data science}  \index{data encryption} \index{data security}
By the middle of the twentieth century, the existence of electrical and electronic devices that enhanced our ability to compute and to intercommunicate, made it imperative that ``the experts'' understand the mathematical laws that govern these activities.  In 1948, the American
mathematician and engineer Claude E.~Shannon revolutionized our understanding of these laws by inventing the field of {\it information theory}  \cite{Shannon48}.  Shannon's intellectual innovations enabled us to quantify the quality of our handling of data: speed of transmission, efficiency of encoding, vulnerability to errors.  The evolution of data science and the ever-increasing importance of information-related topics such as {\it encryption} and {\it data security} make it important that everyone who has contact with the world of computing and communication---which means pretty much everyone---understand at least the rudiments of information theory.  This section is devoted to taking one small step in that direction, a step that hints at the fundamental role that logarithms play in the theory. 

\medskip

One of the most basic results within information theory highlights the role of logarithms in measuring ``the amount of information'' that a string can hold.

\begin{prop}
\label{thm:bound-stringnames-lgth-k}
In any assignment of distinct string-labels to $n$ items, using strings over an alphabet of $a$ symbols, at least one string-label must have length $\geq \lceil \log_a n \rceil$.
\end{prop}

\begin{proof}
Let $A$ be an alphabet of $a$ symbols.  For each integer $k \geq 0$, let $A^{(k)}$ denote the set of all length-$k$ strings over $A$; note that $A^{(1)} = A$.  The bound stated in Proposition~\ref{thm:bound-stringnames-lgth-k} follows by counting the numbers of strings of various lengths over $A$, because each such string can label at most one item.  Let us, therefore, inductively evaluate the cardinality $|A^{(k)}|$ of each set $A^{(k)}$.
\begin{itemize}
\item
$|A^{(0)}| =1$

\smallskip

\index{null string $\varepsilon$}
\index{$\varepsilon$: the null string, of length $0$}
This is because the null string, which is commonly denoted $\varepsilon$,  is the unique string in $A^{(0)}$; symbolically: $A^{(0)} = \{ \varepsilon \}$.

\medskip\item
$|A^{(k+1)}| = |A| \times |A^{(k)}|$

\smallskip

This reckoning follows from the following recipe for building the set $A^{(k+1)}$ from the set $A^{(k)}$.
\[ A^{(k+1)} \ = \ \{ \sigma x \ | \ \sigma \in A \ \ \mbox{ and } \ \ x \in A^{(k)} \} \]
In other words, every length-$(k+1)$ string over $A$ is obtained by taking a length-$k$ string $x$ over $A$ and {\em prepending} to it a symbol from $A$.
\index{prepend a symbol to a string}

\smallskip

This recipe is correct because:
  \begin{itemize}
  \item
Each string in $A^{(k+1)}$, as constructed, has length $k+1$

\smallskip

---because the recipe adds a single symbol to a length-$k$ string.
  \medskip\item
For each string $x \in A^{(k)}$, there are $|A|$ distinct strings in $A^{(k+1)}$, as constructed

\smallskip

---because each string in $A^{(k+1)}$ begins with a distinct symbol from $A$.

  \medskip\item
$A^{(k+1)}$, as constructed, contains all strings of length $k+1$ over $A$

\smallskip

---because every length-$(k+1)$ over $A$ has the form $\sigma x$ for some unique $\sigma \in A$ \\
\hspace*{.14in}and some unique $x \in A^{(k)}$; and the set $A^{(k+1)}$ contains every such string.
  \end{itemize}
\end{itemize}
We thus have the following recurrence.
\begin{eqnarray*}
|A^{(0)}|     & = & 1 \\
|A^{(k+1)}| & = & |A| \times |A^{(k)}| \ \ \ \  \mbox{ for } \ k \geq 0
\end{eqnarray*}
Theorem~\ref{thm:master-thm-simple} tells us that, for each $\ell \in \N$,
\[ |A^{(\ell)}| \ \ = \ \ \frac{|A|^{\ell+1} \ - \ |A|}{|A| -1} \ \ \leq \ \ c' \cdot |A|^{\ell} \]
for some constant $c' > 0$.  In order for this quantity to reach the value $n$, we must have
\[  n \ \ = \ \ |A^{(\ell)}| \ \ \leq \ \ c' \cdot |A|^{\ell} \]
We can rewrite this inequality in the form
\[ |A|^{\ell} \ \ \geq \ \ {1 \over c'} n \]
Because $1/c' > 0$, we can now take logarithms of both sides of the preceding inequality.  Using the logarithm to the base $|A|$ yields the most perspicacious result:
\[ \ell \cdot \log_{|A|} |A| \ \ = \ \ \ell \ \ \geq \ \ \log_{|A|} n \ - \ \log_{|A|} c' \]
Because $n$ grows without bound, while $c'$ is a fixed constant, we can find a value $n_0$ for $n$ such that, for all $n > n_0$, there exists a constant $d' > 0$ such that 
\[ \ell \ > \ d' \cdot \log_{|A|} n   \]
In other words, the string-length $\ell$ must grow logarithmically with the number of strings.  \qed
\end{proof}

%{\Arny Is this enough detail?  Too much detail?  Is the word "perspicacious" too "adult"?}

The following result can be considered another way of looking at 
Proposition~\ref{thm:bound-stringnames-lgth-k}.

\begin{prop}
\label{thm:Num-strings-lgth-k}
The number of distinct strings of length $k$ over an alphabet of $a$ symbols is $a^k$.
\end{prop}

\begin{proof}
As in Proposition~\ref{thm:bound-stringnames-lgth-k}, we focus on an $a$-letter alphabet $A \ = \ \{\sigma_1, \sigma_2, \ldots, \sigma_a\}$ and we argue by induction on string-length $k$.

\medskip

\noindent
{\sf Bases.}
The induction we develop can start either with the unique string $\varepsilon$ of length $k=0$ or with strings of length $k=1$.  In the former case, the uniqueness of the null string validates the case $k=0$ of the proposition.  In the latter case, there are $a^1 = a$ such strings over $A$, one for each symbol $\sigma \in A$; this validates the case $k=1$ of the proposition.

\medskip

\noindent
{\sf The inductive hypothesis.}
Say that for all string-lengths $k$ up through $n$, there are $a^k$ distinct words of length $k$ over $A$.

\medskip

\index{append a symbol to a string}

\noindent
{\sf Extending the induction.}
We take each length-$n$ string $x$ over $A$, and {\em append} to it, in turn, each of $A$'s $a$
symbols.  Each appendage adds an additional rightmost symbol to $x$.  We thereby replace each string $x \in A^{(n)}$ by $a$ distinct new strings, $x \sigma_1$, $x \sigma_2$, \ldots, $x \sigma_a$.  We have thus created $a^{n+1}$ distinct length-$(n+1)$ strings over $A$ from $A$'s $a^n$ distinct length-$n$ strings.

\smallskip

The induction is thus extended, which completes the proof.  \qed
\end{proof}


\section{Bilinear Recurrences}
\label{sec:bilinear-recurrences}
\index{bilinear recurrence}

\subsection{Binomial Coefficients and Pascal's Triangle}
\label{sec:binomial-coeff+Pascal}

\index{binomial coefficient} \index{bilinear recurrence}
In Section~\ref{sec:binomial-coeff}, we introduced and briefly discussed the {\em binomial coefficients} or {\em triangular numbers}, 
\[ \Delta_{n,k} \ \eqdef \ {n \choose k} \]
within the context of binary operations on integers; see Eq.~(\ref{eq:binom-coeff}).  Also, we established in Proposition~\ref{thm:manipulate-binom-coeff} the summation rule
\[ {n \choose k} \ + \ {n \choose {k+1}} \ = \ {{n+1} \choose {k+1}} \]
for these integers.  We now {\em define} binomial coefficients via the {\em bilinear recurrence} that underlies the summation rule.  This change in viewpoint is the topic of the current subsection.

\subsubsection{The formation rule for Pascal's Triangle}
\label{sec:Pascal-formation}

Let us define the bivariate integer function\footnote{We alter our notation for binomial coefficients in deference to our change in viewpoint: We promote the integer pair $\langle n,k \rangle$ from a subscript to an argument, and we embellish $\Delta$ with a ``hat".}~$\hat{\Delta}(n,k)$ via the bilinear recurrence
\begin{equation}
\label{eq:binom-coeff-recurrence}
\hat{\Delta}(n,k) \ = \ 
\left\{
\begin{array}{cl}
1  & \mbox{ if } \ [n=1, k=0] \\
1  & \mbox{ if } \ [n=1, k=1] \\
\hat{\Delta}(n-1, k-1) \ + \  \hat{\Delta}(n-1,k) & \mbox{ otherwise}
\end{array}
\right.
\end{equation}

\smallskip

\index{Pascal's Triangle} 
We claim that the function $\hat{\Delta}(n,k)$ thus defined is, in fact, the binomial coefficient $\displaystyle {n \choose k}$.  We establish this claim with the help of Pascal's Triangle, the two-dimensional array of binomial coefficients which we defined in Section~\ref{sec:binomial-coeff} and illustrated in Fig.~\ref{fig:pascal-triangle}.  Recall that the {\em formation rule of the array} is that the array-entry at (row $n+1$, column $k+1$) is the sum of the array-entries at (row $n$, column $k$) and at (row $n$, column $k+1$).

\index{Pascal's Triangle!formation rule}

\medskip

If you compare the formation rule for Pascal's Triangle with Eq.~(\ref{eq:add-binom-coeff}), then you will anticipate the following result.

\begin{prop}
\label{thm:pascal-binom}
The entries of Pascal's Triangle are the binomial coefficients.

\smallskip

\noindent
Specifically, for all $n,k$, the entry at (row $n$, column $k$) of the Triangle is $\displaystyle {n \choose k}$.
\end{prop}

\begin{proof}
We note by observation and direct calculation (see Fig.~\ref{fig:pascal-triangle}) that the proposition is true for $n = 1$ and $k \in \{0, 1\}$.  A double induction which we leave to the reader verifies that every binomial coefficient appears in the Triangle and every Triangle entry is a binomial coefficient.  \qed
\end{proof}

\medskip

Figures~\ref{fig:binomialCoeff1}--\ref{fig:binomialCoeff3} provide the skeleton of an alternative proof of the summation formula for binomial coefficients.  This proof, which we leave for the interested reader, is our first evidence of the intellectual importance of Pascal's Triangle.
\begin{figure}[htb]
\begin{center}
       \includegraphics[scale=0.4]{FiguresMaths/CoeffBinomiaux1}
\caption{A graph-like representation of Pascal's Triangle.  Note that each entry $\hat{\Delta}(n, k)$ equals the number of paths in the graph from entry $\hat{\Delta}(n, 0)$ to $\hat{\Delta}(n, k)$}
\label{fig:binomialCoeff1}
\end{center}
\end{figure}

\begin{figure}[htb]
\begin{center}
       \includegraphics[scale=0.4]{FiguresMaths/CoeffBinomiaux2}
\caption{Outlining an alternative proof of the summation formula for binomial coefficients:  The number of paths from entry $\hat{\Delta}(n, 0)$ of the Triangle to entry $\hat{\Delta}(n+1, k)$  equals the sum of the number of paths to entry $\hat{\Delta}(n, k)$ and the number of paths to entry $\hat{\Delta}(n, k-1)$}
\label{fig:binomialCoeff2}
\end{center}
\end{figure}

\begin{figure}[htb]
\begin{center}
       \includegraphics[scale=0.4]{FiguresMaths/CoeffBinomiauxCounting}
\caption{Three distinct paths lead from entry $\hat{\Delta}(0,0)$ to entry $\hat{\Delta}(3,2) = {\displaystyle {3 \choose 2}}$}
\label{fig:binomialCoeff3}
\end{center}
\end{figure}

\bigskip

The relation between binomial coefficients and Pascal's Triangle leads us to the following {\it a priori} non-obvious fact.

\begin{prop}
\label{thm:binomcoeff-integer}
Every binomial coefficient is an integer.
\end{prop}
\index{binomial coefficient!integer-hood}

\begin{proof}
By the formation rule for Pascal's Triangle, every entry in that array is obtained from integers via repeated additions---an operation that maps integers to integers. Proposition~\ref{thm:binomcoeff-integer} therefore follows from Proposition~\ref{thm:pascal-binom}'s proof that the elements of the Triangle are precisely the binomial coefficients.  \qed
\end{proof}


\subsubsection{Summing complete rows of Pascal's Triangle}
\label{sec:summaion-BinCoeff}

We conclude this section with a very consequential result about the binomial coefficients, specifically about the sum of all the coefficients that share the same bottom argument.  Of course, we know now that this summation is equivalent to summing complete rows of Pascal's Triangle.


\begin{prop}
\label{thm:sumsof-binomcoeff}
For every positive integer $n$,
\[
\sum_{i=0}^n \ {n \choose i} \ \ = \ \
{n \choose 0} \ + \ {n \choose 1} \ + \cdots + \ {n \choose {n-1}} \ + \ {n \choose n} \ \ = \ \ 2^n
\]
\end{prop}
\index{binomial coefficient!summation formula}

\begin{proof}
This result is an immediate consequence of the Binomial Theorem 
(Theorem~\ref{thm:Binomial-theorem}).  That seminal result tells us that, for all $n \in \N$,
\[ (x+y)^n \ \ = \ \ \sum_{i=0}^n \ \ {n \choose i} x^{n-i} y^i \]
If we instantiate this polynomial equation with the values $x = y = 1$, then we obtain the present result.  \qed
\end{proof}

\smallskip

We shall observe numerous applications of this result as we explore a broad variety of topics, ranging from counting discrete structures and calculating probabilities to deriving basic properties of other recursively defined families.

\subsection{The Fibonacci Number Sequence}
\label{sec:Fibonacci}
\index{Fibonacci number/sequence}

\index{Fibonacci, Leonardo}
\index{Fibonacci, Leonardo!alternative names}
This section is devoted to one of the most storied topics in the world of mathematics---in terms of the topic's manifestation in the real world and in terms of the multiple names used to refer to its discoverer,\footnote{Not surprisingly, this marvelous sequence was discovered many times, in many places.  Our story refers only to its discovery in the West.}~the thirteenth-century Italian mathematician known variously as:

\smallskip

\begin{tabular}{lcl}
Fibonacci                         &  &(abbreviated Italian for: son of Bonaccio) \\
Leonardo of Pisa             &  & (his hometown) \\
Leonardo Pisano             &  & (variant of ``of Pisa'') \\
Leonardo Pisano Bigolo  &  & (his hometown plus family name) \\
Leonardo Fibonacci        &  & (for: son of Bonaccio Bigolo) \\
Leonardo Bonacci           &   & (for: son of Bonaccio Bigolo) \\
\end{tabular}

\medskip

\noindent
The sequence discovered by this multi-named genius is defined as follows.

\medskip

\index{Fibonacci number/sequence!definition}
The {\it Fibonacci sequence} or {\it the Fibonacci numbers} is an infinite sequence
\[ F(0), \ F(1), \ F(2), \ \ldots \]
of {\em positive} integers.  As just denoted, we see that the numbers in the sequence are traditionally indexed by the {\em nonnegative} integers and are often written using functional notation ($F(i)$) rather than as subscripts ($F_i$).  The classical definition of the sequence is via the following bilinear recurrence.
\begin{eqnarray}
\nonumber
F(0) & = & 1 \\
\label{eq:Fibonacci-defn}
F(1) & = & 1 \\
\nonumber
F(n) & = & F(n-1) \ + \ F(n-2) \ \ \ \mbox{ for all } n > 1
\end{eqnarray}
The sequence is often specified---particularly in the popular literature---just by listing its first few elements:
\[ 1, \ 1, \ 2, \ 3, \ 5, \ 8, \ 13, \ 21, \ 34, \ \ldots \]


\subsubsection{The story of the Fibonacci numbers}
\label{sec:Fibonacci-story}
\index{Fibonacci number/sequence!story}

Leonardo Fibonnaci describes\footnote{In his {\it Liber Abaci}, 1202} discovering his eponymous sequence of integers in the course of contemplating the rate of population growth of successive generations beginning with an idealized immortal initial pair of {\it rabbits}.

\smallskip

Rabbits mature quickly and, after attaining maturity at age one month, they can spawn a new pair of progeny every subsequent month.  So, let us begin ``at time $0$'', with one pair of newborn rabbits.  We continue with just the initial pair of rabbits at month $1$, because there has not yet been time for the pair to spawn new rabbits.  By month $2$, though, there are two pairs of rabbits.  At month $3$, only the first pair will have spawned---because the second pair is too young---so there are three pairs of rabbits.  At month $4$, these three pairs are joined by two more.  The reader who continues this story will discover that {\em the number of pairs of rabbits observed after successive months is specified by the process implicit in recurrence (\ref{eq:Fibonacci-defn})}.  Figure~\ref{fig:fibo5} illustrates the process up to month $5$.  
%{\Arny Bunnies are your department, mon ami!}
\begin{figure}[htb]
\begin{center}
        \includegraphics[scale=0.275]{FiguresMaths//Fibo5}
\caption{The successive generations of rabbits for the first five months}
        \label{fig:fibo5}
\end{center}
\end{figure}

\smallskip

The Fibonacci sequence's ability to describe idealized rabbit population statistics is just a hint of its appearance elsewhere in the natural world---in structural features such as the patterns of seeds in flower heads, the numbers of petals of flowers, the growth patterns of pine cones and pineapples, and on and on; see \cite{Basin63}.

\medskip

\index{golden ratio, $\Phi$} \index{$\Phi$, the golden ratio}
The story of this fascinating sequence of numbers has a ``universal" aspect also.  Many cultures---the ancient Greeks among them---have ascribed mystical properties to (classes of) numbers:  Our discussions of the {\it prime numbers} in Section~\ref{sec:primes} and the {\it perfect numbers} in Section~\ref{sec:perfect-numbers+Mersenne-primes} bear witness to this
phenomenon.  One specific number that has attracted such attention is the {\it golden ratio} $\Phi$, an irrational real number which has the following (exact and approximate) values: 
\[ \Phi \ = \ \frac{1+\sqrt{5}}{2} \ \approx \  1.618\cdots \]
It has been alleged that rectangles whose {\it aspect ratios} (Length $\div$ Width) are (roughly) $\Phi$ are the most pleasing to the human eye.  In fact, the aspect ratio of the Parthenon in Athens is (roughly) $\Phi$---although it is not known whether this is intentional.  The relevance of $\Phi$ to the current section resides in the fact that {\em the sequence of ratios of successive Fibonacci numbers approaches $\Phi$}.

\smallskip

You can make your own observations regarding rectangles with pleasing aspect ratios and the ratios of successive Fibonacci numbers by perusing Fig.~\ref{fig:fibosquare}.
\begin{figure}[htb]
\begin{center}
        \includegraphics[scale=0.35]{FiguresMaths//Fiboembedded}
\caption{Successive Fibonacci numbers interpreted geometrically, via a spiral of squares whose respective side-lengths form a Fibonacci sequence}
        \label{fig:fibosquare}
\end{center}
\end{figure}

The mathematical properties of this truly remarkable sequence will be our focus in the remainder of this section.


\subsubsection{Fibonacci numbers and binomial coefficients}
\label{sec:FibNo+BinomCoeff}
\index{Fibonacci number/sequence!connection with binomial coefficients}
\index{binomial coefficient!connection with Fibonacci numbers}

%\begin{figure}[h]
%\begin{center}
%        \includegraphics[scale=0.4]{FIGmaths/DefFibo}
%        \caption{Principle of the Fibonacci progression}
%        \label{doublesum}
%\end{center}
%\end{figure}
%Notice that it is a special case of $u_{n+1} =\alpha.u_{n} + \beta.u_{n-1}$ for $\alpha=\beta=1$.
%\bigskip

\noindent
There is a strong, non-obvious connection between the binomial coefficients (cf.~Section~\ref{sec:binomial-coeff+Pascal}) and the Fibonacci numbers.  We observe this connection by contemplating the diagonals of Pascal's Triangle.  Figure~\ref{fig:FiboPascal} and Proposition~\ref{thm:FibNo+BinomCoeff} establish this connection.
\begin{figure}[htb]
\begin{center}
        \includegraphics[scale=0.3]{FiguresMaths//FiboPascal1}
\caption{Obtaining Fibonacci numbers as the sums of diagonal elements of the left-justified Pascal Triangle}
\label{fig:FiboPascal}
\end{center}
\end{figure}

\begin{prop}
\label{thm:FibNo+BinomCoeff}
For all $n \in \N$, the Fibonacci number $F(n)$ is the sum of the first $\lceil (n+1)/2 \rceil$ binomial coefficients $\displaystyle {k  \choose i}$ such that $k+i = n$.  Symbolically,
\begin{equation}
\label{eq:FibNo+BinomCoeff}
F(n) \ = \ {n \choose 0} \ + \ {{n-1} \choose 1} \ + \cdots + \ 
{{\lfloor (n+1)/2 \rfloor} \choose {\lceil (n+1)/2 \rceil -1}}
\end{equation}
\end{prop}

\begin{figure}[htb]
\begin{center}
        \includegraphics[scale=0.3]{FiguresMaths//FiboPascal2}
\caption{Each term of the diagonal is obtained by summing the two preceding ones}
        \label{fig:FiboPascalExplanation}
\end{center}
\end{figure}

\begin{proof}[Sketch]
Because of the heavy calculational content of a complete proof, we provide here just a short sketch.

\smallskip

Figure~\ref{fig:FiboPascalExplanation} depicts a portion of Pascal's Triangle with shaded diagonal and horizontal annotations.  The diagonal annotation depicts the three numbers in the Triangle that sum to the Fibonacci number $F(5)$.
\begin{enumerate}
\item
Looking at the three horizontal shaded areas {\em individually} illustrates the relationship asserted by the proposition.  Each of the three numbers on the shaded diagonal, namely, $1$, $4$, and  $3$, is a binomial coefficient; therefore, the number is the sum of the two numbers on the preceding row of the array: These sums are instantiations of the formation rule for Pascal's Triangle.  The illustrated instance of the rule asserts that:
\[
\begin{array}{ccccccc}
{\displaystyle {5 \choose 0}}
 & = &
{\displaystyle 0 + {4 \choose 0} }
 & = &
0 + 1
 & = & 1 \\ \\
{\displaystyle {4 \choose 1}}
 & = &
{\displaystyle {3 \choose 0} + {3 \choose 1} }
 & = &
1 + 3
 & = & 4 \\ \\
{\displaystyle {3 \choose 2}}
 & = &
{\displaystyle {2 \choose 1} + {2 \choose 2} }
 & = &
2 + 1
 & = & 3
\end{array}
\]
\medskip\item
Looking at the three horizontal shaded areas {\em in tandem} illustrates that the numbers along the shaded diagonal are sums of the numbers along the two diagonals that sit above the shaded one:  These numbers are instantiations of the formation rule for Fibonacci numbers.  The
illustrated instance of the rule asserts that
\[ F(5) \ = \ F(4) + F(3) \ = \ 5 + 3 \ = \ 8 \]
\end{enumerate}

The preceding reasoning provides the infrastructure for an induction which proves that the proposition holds for {\em every} Fibonacci number.  As suggested by the statement of the proposition, the required calculations on indices can obscure the rather elegant basis for the result.  \qed
\end{proof}

\subsubsection{Alternative origins for the Fibonacci sequence}
\label{sec:Fibonacci-other-recurrences}

Although the classical recurrence (\ref{eq:Fibonacci-defn}) is the structurally simplest generator of the Fibonacci sequence, there exist other generators that are not much more complex.  We now present several alternative ways to generate the sequence: (A) two other multilinear recurrences; (B) a family of binary generating recurrences; (C) a combinatorial approach.

\paragraph{A. Two multilinear generating recurrences}
\index{Fibonacci number/sequence!additional multilinear generating recurrences}

\begin{prop}
\label{thm:FiboSum-1}
For all integers $n \geq 2$,
\begin{eqnarray}
\label{eq:multilinear-Fib-1}
F(n) & = &
1 \ + \ F(0) \ + \ F(1) \ + \ F(2) \ + \cdots + \ F(n-2) \\
\nonumber
     & = &
1 \ + \ \sum_{k=0}^{n-2} F(k)
\end{eqnarray}
\end{prop}

\begin{proof}
We proceed by induction.

\smallskip

\noindent
{\sf Base}. The base case, $n=2$, holds because $F(2) \ = \ 2 \ = \ 1 + F(0)$.

\smallskip

\noindent 
{\sf Inductive hypothesis}.
Assume, for induction, that Eq.~(\ref{eq:multilinear-Fib-1}) holds for all arguments $2 \ \leq \ m  \ < \ n$.

\smallskip

\noindent 
{\sf Inductive extension}.
We extend the induction as follows.  Our inductive hypothesis assures us that for all $n \geq 3$,
\[ F(n-1) \ = \ 1 \ + \ F(0) \ + \ F(1) \ + \ F(2) \ + \cdots + \ F(n-3) \]
Combining this with the classical recurrence (\ref{eq:Fibonacci-defn}), we therefore have
\begin{eqnarray*}
F(n) & = & F(n-2) \ + \ F(n-1) \\
     & = &
F(n-2) \ + \ 1 \ + \ F(0) \ + \ F(1) \ + \ F(2) \ + \cdots + \ F(n-3)
\end{eqnarray*}

\noindent
This extends the induction and completes the proof.
\qed
\end{proof}

\medskip

While recurrence (\ref{eq:multilinear-Fib-1}) in Proposition~\ref{thm:FiboSum-1} employs all of the Fibonacci numbers up to the desired bound, recurrence (\ref{eq:multilinear-Fib-2}) in the next proposition employs only every other such number.

\begin{prop}
\label{thm:FiboSum-2}
For all integers $n \geq 2$,
\begin{equation}
\label{eq:multilinear-Fib-2}
F(n) \ \ = \ \
F(n-1) \ + \ F(n-3) \ + \ F(n-5) \ + \cdots + \ 1
\end{equation}
We thereby sum every other Fibonacci number as long as we can.
\end{prop}

\begin{proof}
We verify summation (\ref{eq:multilinear-Fib-2}) by iteratively expanding the right-hand term ---i.e., $F(n-2)$---of the classical recurrence (\ref{eq:Fibonacci-defn}).  This expansion begins
\begin{eqnarray}
\label{eq:multilinear-Fib-3}
F(n)
  & = & F(n-1) \ + \ F(n-2) \\
\nonumber
  & = & F(n-1) \ + \ F(n-3) \ + \ F(n-4) \\
\nonumber
  & = & F(n-1) \ + \ F(n-3) \ + \ F(n-5) \ + \ F(n-6)
\end{eqnarray}
Note that all term-indices in the expanded summation have the same parity: The sequence of expanded indices begins $n-2$, $n-4$, $n-6$, \ldots, so successive expanded indices always differ by $2$; therefore, the index $n-k$ that we expand always has the same parity as $n$.

\smallskip

We continue the process of expanding recurrence (\ref{eq:multilinear-Fib-3}) as long as we can---i.e., until we encounter either $F(0)$, in the case of even $n$, or $F(1)$, in the case of odd $n$.  In both cases, we will have ``run out of Fibonacci numbers'', so the expansion terminates---coincidentally with the final term $1$.  \qed
\end{proof}


\paragraph{B. A family of binary generating recurrences}
\index{Fibonacci number/sequence!a family of binary generating recurrences}


What we have earlier called ``generating recurrences'' or ``formation rules'' for binomial coefficients and Fibonacci numbers can also be viewed as (mathematical) identities on the quantities of interest.  In our usage, the line between ``generating recurrence'' and ``identity'' centers on computational issues: multilinear recurrences can feasibly be used to generate the desired numbers; nonlinear recurrences such as we expose in this subsection will likely not be used as generators.  Indeed, for several of the results we cover here, we really want to stress the {\em methodology of proof and analysis}.

\begin{prop}
\label{thm:Fib-higher-indices}
For all $n \in \N$ and $0 < k < n$
\begin{equation}
\label{eq:Fib-higher-indices}
F(n) \ = \ F(k) \cdot F(n-k) \ + \ F(k-1) \cdot F(n-k-1)
\end{equation}
\end{prop}

Of course, the classical recurrence (\ref{eq:Fibonacci-defn}) is instance $(k = 1)$ of the family of recurrent equations (\ref{eq:Fib-higher-indices}).

\begin{proof}
We first explain how one might guess at the existence of the family of recurrences (\ref{eq:Fib-higher-indices}).  Then we validate the recurrences in the family.

\smallskip

We begin with the classical recurrence (\ref{eq:Fibonacci-defn}) and iteratively use this recurrence to ``expand'' the classical recurrence.  In detail, we begin by combining the first two instances of (\ref{eq:Fibonacci-defn}), namely,
\[
\begin{array}{lcrrr}
F(n)   & = & F(n-1) & + & F(n-2) \\
F(n-1) & = & F(n-2) & + & F(n-3)
\end{array}
\]
and we combine them algebraically to produce the following.
\[ F(n) \ = \ 2 F(n-2) \ + \ F(n-3) \]
And then we iterate!  The following table illustrates the result of the first four iterations of the process.
\[
\begin{array}{ccrcrcrcrcrcr}
F(n) & = & F(n) & + & F(n-1) \\
     & = &      &   & 2 F(n-1) & + & F(n-2) \\
     & = &      &   &          &   & 3 F(n-2) & + & 2 F(n-3) \\
     & = &      &   &          &   &          &   & 5 F(n-3) & + & 3 F(n-4)  \\
     & = &      &   &          &   &          &   &          & + & 8
F(n-4) & + & 5 F(n-5)  \\
 & \vdots  &  & \vdots  &  &  \vdots &  & \vdots
 &  & \vdots  &   & \vdots  & 
\end{array}
\]
Note that the coefficients of the successive occurrences of the Fibonacci numbers $F(i)$ that occur in our table are themselves Fibonacci numbers.  By analyzing the emerging pattern---{\em remember our advice in Chapter~\ref{ch:doingmath} to always look for patterns}---we arrive at the family (\ref{eq:Fib-higher-indices}) of recurrent equations.

\bigskip

\noindent \fbox{
\begin{minipage}{0.95\textwidth}
{\bf Explanatory note}.

\smallskip

Keep in mind that, at this point, we are still in the realm of conjecture!  The observed pattern {\em appears to be} converging to generic recurrence (\ref{eq:Fib-higher-indices}).  We must now verify the universal validity of the family.
\end{minipage}
}
\bigskip

We proceed by induction on the number $k$ of iterated expansions of the classical recurrence (\ref{eq:Fibonacci-defn}).

\medskip

\noindent
{\sf Basis}.
The basis for our induction resides in the observation we shared right after stating the proposition: Instance $(k = 1)$ of the posited family of recurrent equations is just the classical recurrence (\ref{eq:Fibonacci-defn}).

\medskip

\noindent
{\sf Inductive hypothesis}.
Assume that instance $k$ of family (\ref{eq:Fib-higher-indices})---i.e., the equation
\[ F(n) \ = \ F(k) \cdot F(n-k) \ + \ F(k-1) \cdot F(n-k-1) \]
is valid.  {\em Note that validity requires that $k < n-1$.}

\medskip

\noindent
{\sf Inductive extension}.
Let us observe, under the validity assumption, the result of producing instance $k+1$ from this instance.  We algebraically combine the just-cited equation with the following instantiation of the classical recurrence:
\[ F(n-k) \ = \ F(n-k-1) \ + \ F(n-k-2) \]
We find that
\begin{eqnarray*}
F(n) & = & F(k) \cdot F(n-k) \ + \ F(k-1) \cdot F(n-k-1) \\
     & = & F(k) \cdot \big[ F(n-k-1) \ + \ F(n-k-2) \big]  \ +
             \ F(k-1) \cdot F(n-k-1) \\
     & = & \big[ F(k) \ + \ F(k-1) \big] \cdot F(n-k-1) \ + \ F(k)
             \cdot F(n-k-2) \\
     & = & F(k+1) \cdot F(n-k-1) \ + \ F(k) \cdot F(n-k-2)
\end{eqnarray*}
The induction is thus extended, which establishes the proposition.  \qed 
\end{proof}


\paragraph{C. A combinatorial setting for the sequence}
\index{Fibonacci number/sequence!in binary strings with no consecutive $1$s}
\index{Fibonacci number/sequence!a combinatorial setting}

In Section~\ref{sec:Fibonacci-story}, we described several settings in which one can identify the Fibonacci sequence.  The settings we chose arose in nature---rabbits, pineapples, etc.  We now describe a {\em mathematical} setting in which the sequence arises.  In common with our rabbits and pineapples, this setting does not involve the solution of a system of recurrent equations.  In common with our equational settings, this setting is purely mathematical.

\medskip

Our setting is {\em combinatorial} in nature, in the sense that the Fibonacci numbers emerge as we count instances of some phenomenon. But, of course, the generating recurrence is still present; it is just camouflaged by the counting.

\bigskip

For each positive integer $n$, let $S_n$ be the set of all length-$n$ binary strings in which {\em every occurrence of bit $1$ is directly preceded by an occurrence of bit $0$}.  Table~\ref{tab:comb-FIB} provides the first few instances of $S_n$, with their cardinalities.
\begin{table}[hbt]
%\label{tab:comb-FIB}
\caption{The first few instances of $S_n$, with their cardinalities}
\[
\begin{array}{|c|c|c|}
\hline
n = & S_n =               & |S_n| = \\
\hline
0   & \{ \varepsilon\}    & 1 \\ 
1   & \{ 0 \}             & 1 \\
2   & \{ 00, 01 \}        & 2 \\
3   & \{ 000, 001, 010 \} & 3 \\
\hline
\end{array}
\]
\label{tab:comb-FIB}
\end{table}

\begin{prop}
\label{thm:FIBO-from-sparse-bitstrings}
For each $n \in \N^+$, the number of length-$n$ binary strings in which each occurrence of a $1$ is directly preceded by a $0$ is the Fibonacci number $F(n)$.
\end{prop}

\begin{proof}
By definition, every binary string $w \in S_n$ ends either with $0$ or with $01$.
\begin{itemize}
\item
If $w$ ends with $0$, then it has the form $w = x0$, where the prefix $x$ is a binary string of length $n-1$; moreover, $x$ must belong to $S_{n-1}$ in order for $w$ to belong to $S_n$.  $S_n$ therefore contains $|S_{n-1}|$ strings of this form.

\medskip\item
If $w$ ends with $01$, then it has the form $w = y01$, where the prefix $y$ is a binary string of length $n-2$; moreover, $y$ must belong to $S_{n-2}$ in order for $w$ to belong to $S_n$.  $S_n$ therefore contains $|S_{n-2}|$ strings of this form.
\end{itemize}

The preceding reckoning implies that the cardinalities of the sets $S_n$ obey the following recurrence.
\[
\begin{array}{ccll}
|S_0| & = & 1 & \mbox{see Table~\ref{tab:comb-FIB}} \\
|S_1| & = & 1 & \mbox{see Table~\ref{tab:comb-FIB}} \\
|S_n| & = & |S_{n-1}| \ + \ |S_{n-2}| & \mbox{see preceding analysis}
\end{array}
\]
This recurrence is just a relabeled version of the Fibonacci recurrence (\ref{eq:Fibonacci-defn}).  \qed
\end{proof}



\subsubsection{$\oplus$ A closed form for the $n$th Fibonacci number}
\label{sec:Fib-Golden-Ratio}

\ignore{***************
The Fibonacci series is given by the recurrence:
$F(n+1) = F(n) + F(n-1)$.
The characteristic equation is thus given by:
$x^2 = x + 1$ or $x^2 - x - 1 = 0$ whose roots are determined by solving the equation for $a=1$ and $b=c=-1$.

$\Delta = b^2 - 4.a.c = 1+4 = 5$

As both roots are centered apart $x^*=\frac{-b}{2a}= \frac{1}{2}$, corresponding to $y^*= -\frac{\Delta}{4a} = -\frac{5}{4}$, we can rewrite the equation as:

$(x-\frac{1}{2})^2 - \frac{5}{4} = 0$

This gives: $(x-\frac{1}{2})^2 = \frac{5}{4}$ and thus, $x_1-\frac{1}{2} = - \sqrt{\frac{5}{4}}$ or $x_2-\frac{1}{2} = + \sqrt{\frac{5}{4}}$.

The last value is the Golden ratio: $\Phi = \frac{1}{2} + \sqrt{\frac{5}{4}} = \frac{1+\sqrt{5}}{2}$

\begin{figure}[htb]
\begin{center}
       \includegraphics[scale=0.3]{FiguresArithmetic/SecondDegreeFibo}
\caption{Determining graphically the Golden ratio (second root, denoted by $x_2$).}
\label{fig:SecondDegreeFibo}
\end{center}
\end{figure}
******************}

\index{heuristic}

\noindent
We close our survey of the Fibonacci numbers by exposing a {\it closed-form expression}\footnote{The term ``closed-form expression'' is defined and illustrated in Section~\ref{sec:special-arithmetic-sums}.}~for the numbers in this fascinating family.  The
detailed derivation of this expression requires advanced material that is beyond the scope of this text, so we settle for a {\em heuristic} explanation.

\bigskip

\noindent \fbox{
\begin{minipage}{0.96\textwidth}
{\bf Explanatory note}.

\smallskip

By ``heuristic explanation'', we mean the kind of intuitive explanation that mathematicians and scientists often use to garner intuition during the exploratory phase of studying a complex topic.  As one's intuition grows, one hopes to eventually replace the heuristic explanation with a rigorous one.  In the case of the sought closed-form expression for the $n$th Fibonacci number, the sought rigor must await rather advanced concepts and tools.
\end{minipage}
}

\bigskip 

If you were to write out a sufficiently long initial sequence of Fibonacci numbers, you would observe that they grow quite fast.  Indeed, by this point in the text, you have hopefully ``played'' with enough sequences that you might guess that the Fibonacci numbers $\{ F(n) \}$ grow {\em exponentially} in the index $n$.  In detail, you would be guessing that there exists a real base $\beta > 1$ and a constant of proportionality $c > 0$ such that $F(n) = c \beta^n$, at least approximately.  In order to (hopefully!)~garner intuition for the actual growth behavior of the Fibonacci numbers, let us observe an important corollary of the ``exponential" guess.  If the guessed form were accurate, then it would combine with recurrence (\ref{eq:Fibonacci-defn}) in the following way.
\[ \begin{array}{cccll}
(1) & F(n) & = & c \beta^n
      & \mbox{ by our guess} \\
(2) & F(n) & = & F(n-1) \ + \ F(n-2)
      & \mbox{ by recurrence (\ref{eq:Fibonacci-defn})}
\end{array}
\]
By combining (1) and (2), we therefore find that
\[ \beta^n \ = \ \beta^{n-1} \ + \ \beta^{n-2} \]
so that $\beta^n$ is a root of the quadratic equation
\[
x^2 - x - 1 \ = \ 0
\]
By the quadratic formula---see Proposition~\ref{thm:quadratic-formula}---this polynomial has two roots: 
\[ \Phi \ = \ {\displaystyle \frac{1+\sqrt{5}}{2}} \ \ \ \mbox{ and } \ \ \
\Phi' \ = \ {\displaystyle \frac{1-\sqrt{5}}{2}} \]

%{\Denis well done, I like the way this is presented, but where is the  section on quadratic formula?}
%{\Arny Proposition~\ref{thm:quadratic-formula}) is in Chap 5; this is in Chap 8}

\smallskip

\index{golden ratio, $\Phi$}
\noindent
Note that $\Phi$, which is known as the \textit{golden ratio}, exceeds $1$ while $\Phi'$ does not.  Since we know that the Fibonacci numbers {\em grow} with $n$ rather than shrink with $n$, our initial guess would assign $F(n)$ the value
\[ F(n) \ = \ \Phi^n \ = \ {\displaystyle \left( \frac{1+\sqrt{5}}{2} \right)^n } \]
In fact, this guessed value of $F(n)$ is off by only a small constant factor, at least for very large values of $n$---as exposed by part (a) of the following result.  Part (b) of the result actually provides the sought closed-form expression for $F(n)$.
\index{Fibonacci number/sequence!closed-form expression}

\begin{prop}
\label{thm:FibNo-GoldenRatio}
{\bf (a)} {\rm (An approximating expression)}
For all sufficiently large $n$,
\[ F(n) \ \approx \ \frac{1}{\sqrt{5}} \left(\frac{1+\sqrt{5}}{2} \right)^n \]
The symbol ``$\approx$'' here means that the relative error incurred by approximating $F(n)$ via this expression shrinks exponentially fast as $n$ grows.

\medskip

\noindent{\bf (b)} {\rm (An exact expression)}
For all $n$,
\[ F(n) \ = \ 
\frac{1}{\sqrt{5}} \left( \left(\frac{1+\sqrt{5}}{2} \right)^n - \left(\frac{1-\sqrt{5}}{2} \right)^n \right)
\]
\end{prop}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{$\oplus$ Recurrences ``in Action'': The Token Game}
\label{sec:TokenGame}

In order to truly appreciate the power of recurrences as an analysis tool, one must witness them ``in action''.  
To this end, we now describe the ({\it single-player}) combinatorial {\it Token Game}.\footnote{This game is inspired by the \textit{Baguenaudier} introduced by \'{E}douard Lucas~\cite{Lucas}. It is also known as the Chinese rings.}
By employing recurrences to analyze plays of the game, we are able to derive an optimal strategy for playing the game.

\subsection{Rules of the Game}
\label{sec:TokenGame-Rules}

\noindent {\it The equipment}.
For each $n \in \N^+$, the order-$n$ Token Game is played with:
\begin{itemize}
\item
a {\it bank} that has $n$ {\it slots}, labeled $1$, \ldots, $n$
\medskip\item
a {\it pile} of $n$ tokens, each capable of completely occupying a bank slot.
\end{itemize}

\smallskip

\noindent {\it Initial and terminal configurations}.
Each play of the game begins with the bank empty and the pile full, as depicted in Fig.~\ref{fig:jeujetonsInit}.
\begin{figure}[htb]
\begin{center}
        \includegraphics[scale=0.35]{FiguresMaths/GameTokenInit.png}
\caption{The initial configuration of the Token Game: Each of the $n$ tokens appears as a grey circle, and the empty bank has $n$ slots.  In the figure, $n=8$}
        \label{fig:jeujetonsInit}
\end{center}
\end{figure}

\medskip

\noindent {\it The goal of the game}.
The player's goal is to transfer all $n$ tokens from the pile into the bank.

\medskip

\noindent {\it The repertoire of Game moves}.
The player transfers tokens from the pile to the bank by executing a sequence of {\it moves}, each having one of the following types.
\begin{enumerate}
\item
Change the state of bank-slot \#$1$, which is the first (i.e., leftmost) slot in the bank:

\smallskip

If slot \#$1$ is empty, then move a token from the pile to that slot.

\smallskip

If slot \#$1$ is full (i.e., contains a token), then remove this token and return it to the pile; see Fig.~\ref{fig:rule1}.
\begin{figure}[h]
\begin{center}
        \includegraphics[scale=0.3]{FiguresMaths/GameTokenRule1.png}
\caption{(Top) Slot \#1 contains a token.  (Bottom) Therefore, remove it (i.e., move it back to the pile)}
        \label{fig:rule1}
\end{center}
\end{figure}

\medskip\item
Change the state of the bank-slot---call it slot \#$s$---that is immediately to the right of the first (i.e., leftmost) {\em empty} slot:

\smallskip

If slot \#$s$ is empty, then move a token from the pile to that slot.

\smallskip

If slot \#$s$ is full (i.e., contains a token), then remove this token and return it to the pile; see Fig.~\ref{fig:rule2}.
\begin{figure}[htb]
\begin{center}
        \includegraphics[scale=0.3]{FiguresMaths/GameTokenRule2.png}
\caption{(Top) Bank-slot \#$s$, which is immediately to the right of the first empty slot ($s=3$ in this example) is empty.  (Bottom) Therefore, move a token from the pile into slot \#$3$}
        \label{fig:rule2}
\end{center}
\end{figure}
\end{enumerate}

\medskip

\noindent {\it Objective of a play of the Game:}
To minimize the number of moves from an initially empty bank to the finally full bank.

\subsection{An Optimal Strategy for Playing the Game}
\label{sec:Token-Game-Strategies}

The question is how the player should choose successive moves, with the goal of filling the bank as quickly as possible.  One can garner some strategic observations about how to play the Game by looking at small instances. 
\begin{itemize}
\item
When $n=1$, the player should simply fill the slot using a Type-$1$ move.
\medskip\item
When $n=2$, the player must first play a Type-$2$, then a Type-$1$ move. 
\medskip\item
As the Game proceeds for the next small values of $n$ (say $n=3, 4$, or $5$), observation suggests that the player should begin with a Type-$1$ move when $n$ is odd and with a Type-$2$ move when $n$ is even. 
\medskip\item
Another easy observation is: The player should not play two successive moves of the same type, because the second one just undoes the first.
\end{itemize}
A strategy is beginning to emerge:
\begin{enumerate}
\item
Choose the initial move based on the parity of $n$.
\medskip\item
Subsequently, alternate between the two types of moves.
\end{enumerate}
This strategy is pleasingly simple, but: (a) Does it lead us to the required terminal state?  (b) What is the cost of a (successful) play using this strategy?  The answers to both questions can be discovered if we reformulate the strategy to a {\em recursive} form:  We can then use recurrences to prove that the proposed strategy is optimal and to evaluate the cost of an optimal play of the order-$n$ game.

\bigskip

We play the small instances of the Game---the cases $n=1$ and $n=2$---using the {\it ad hoc} strategies mandated by our earlier observations.  For Game instances with $n > 2$, we devise a recursive solution, which is motivated by the following reasoning.

\medskip

A token can be placed into the {\em last} bank-slot (i.e., the $n$th) via the Type-$2$ move

\smallskip

\hspace*{.35in}
{\sc move token from pile into bank-slot} $n$

\smallskip

\noindent
In order for this move to be eligible for execution, the bank must be in the following configuration, reading rightward from bank-slot $1$:
\[ \big[ \mbox{tokens in slots } \ 1, 2, \ldots, n-2 \big],
 \big[ \mbox{no token in slot } \ n-1 \big],
 \big[ \mbox{no token in slot } \ n \big]
\]
This configuration requires that the first $n-2$ slots have been filled.  (Note that, importantly, $n-2$ has the same parity as $n$.)

\smallskip

Once the player has achieved this configuration and executed the mandated move, the player henceforth ignores the token in bank-slot $n$.   Here comes the recursion!

\medskip

{\em The player is now confronting the initial configuration of the order-$(n-1)$ Game!}

\medskip

Thus, in this recursive formulation, the Game can be played by recursively executing the {\em super-steps} depicted in Figure~\ref{fig:jeujetonsPrinciple}, on successively smaller banks and piles.
\begin{figure}[htb]
\begin{center}
        \includegraphics[scale=0.3]{FiguresMaths/GameTokenPrinciple.png}
\caption{A schematic of the recursive play of the current-sized version of the Game.  The top four bank configurations indicate the four iterating super-steps in the recursions.  The bottom bank configuration is the final one: The bank is entirely filled }
        \label{fig:jeujetonsPrinciple}
\end{center}
\end{figure}
We summarize the super-steps:
\begin{enumerate}
\item
{\it Topmost bank configuration $\rightarrow$ Second bank configuration}

\smallskip

Move tokens into the leftmost $n-2$ slots of the bank, leaving the rightmost two slots empty.

\medskip\item
{\it Second bank configuration $\rightarrow$ Third bank configuration}

\smallskip

Move a token into bank-slot $n$, i.e., the current rightmost slot

\medskip\item
{\it Third bank configuration $\rightarrow$ Fourth bank configuration}

\smallskip

Empty  bank-slots $1, 2, \ldots n-1$; i.e., leave the current rightmost slot filled, but empty all slots to its left.

\medskip\item
{\it Final bank configuration}

\smallskip

The Game is complete!
\end{enumerate}


\ignore{**************
\medskip
We can specify the preceding recursive algorithm in the following more
formal format:

\medskip

\begin{tabular}{|l|c|ll|}
\multicolumn{4}{l}{{\bf Recursive-Procedure} Fill-Bank($n$)} \\
\hline
\multicolumn{4}{l}{/* Fill the leftmost $n$ slots of the currently
  empty bank */} \\
\hline
\hline
\underline{\bf Case} & \underline{\bf Move-sequence} & 
\multicolumn{2}{c}{\underline{\bf Action}} \\ 
$n=1$ &   & Move-Token to slot \#$1$ & via a Type-$1$ move \\
\hline
$n=2$ & 1 & Move-Token to slot \#$2$ & via a Type-$2$ move \\
      & 2 & Move-Token to slot \#$1$ & via a Type-$1$ move \\
%PutToken(2) -- Rule 2 -- and then PutToken(1) -- Rule 1
\hline
$n>2$ & 1 & Fill-Bank($n-2$) & via recursive invocation \\
%\medskip\item fillBank(n-2)
      & 2 & via a Type-$2$ move \\
%\medskip\item PutToken(n)
      & 3 & Erase leftmost $n-2$ bank-slots & as described in text \\
%\medskip\item EmptyBank(n-2)
      & 4 & Fill-Bank($n-1$) & via recursive invocation \\
%\medskip\item FillBank(n-1)
\hline
\end{tabular}
***************}


\subsection{$\oplus \oplus$ Analyzing the Recursive Strategy}
\label{sec:analysis-of-Token-Game}

Not surprisingly, our analysis of the optimal recursive strategy for playing the Token Game resides in a {\em recurrence} for the cost of playing the Game, as a function of the bank-size $n$.  Also not surprisingly, the structure of the recurrence mirrors the structure of our recursive playing strategy.

\medskip

For $i = 1, \ldots, n$, let $f(i)$ denote the cost of filling the bank-slots \#$1$ through \#$i$, measured in terms of the number of atomic moves, each of the form {\sc place a token} or {\sc remove a token}.  Because of the dual forms of our atomic moves---each move fills one slot that is empty or empties one slot that is full---the cost of filling an empty length-$i$ prefix of the bank with tokens equals the cost of emptying a full length-$i$ prefix of the bank.  The total cost of a play of the order-$n$ Game is the cost of filling the initially empty $n$-slot bank with tokens.

\begin{prop}
\label{thm:f-cost of TokenGame}
Let $f(n)$ be the cost of a play of the order-$n$ Token Game.  For each $n \in \N^+$, $f(n)$ is given by:
\begin{equation}
\label{eq:f-cost:Token-Game}
f(n) \ = \ \left\{
\begin{array}{ll}
  \left( 2^{n+1} -1 \right)/3
         & \mbox{  if $n$ is odd} \\
  \left( 2^{n+1} -2 \right)/3
        & \mbox{  if $n$ is even}
\end{array}
\right.
\end{equation}
\end{prop}

\begin{proof}
Our discussion has revealed that the analysis of our recursive playing strategy resides in solving the following recurrence.
\begin{equation}
\label{eq:Token-cost-recurrence}
f(n) \ = \ \left\{
\begin{array}{ll}
1 & \mbox{ if } \ n=1 \\
2 & \mbox{ if } \ n=2 \\
f(n-1) \ + \ 2 f(n-2) + 1 & \mbox{ if } \  n > 2
\end{array}
\right.
\end{equation}

\medskip

\noindent \fbox{
\begin{minipage}{0.95\textwidth}
{\bf Explanatory note}.

\smallskip

There is a point to clarify here because the moves of the Game are not \textit{symmetric}---we always proceed from left to right. 

\smallskip

The recursive solution involves a super-step that empties a bank of size $n-2$.  It appears that filling and emptying a bank are mirror-image operations.  Indeed, for small $n$, the sequence of operations that empties the bank is the reverse of the sequence that fills the bank.  We now verify that the symmetry always holds.

\medskip

The cost of the recursive solution is:
\begin{equation}
\label{eq:game-fill}
f(n) \ = \ \left\{
\begin{array}{ll}
1 & \mbox{ if } \ n=1 \\
2 & \mbox{ if } \ n=2 \\
f(n-2) \ + \ 1 \ + \ f^{-1}(n-2) \ + \ f(n-1) & \mbox{ if } \  n > 2
\end{array}
\right.
\end{equation}
Let $f^{-1}$ denote the bank-emptying operation.  If one thinks in terms of mirror-image operations, then one discovers a recursive solution for emptying the bank:
\begin{equation}
\label{eq:game-empty}
f^{-1}(n) \ = \ \left\{
\begin{array}{ll}
1 & \mbox{ if } \ n=1 \\
2 & \mbox{ if } \ n=2 \\
f^{-1}(n-1) \ + \ f(n-2)  \ + \ 1 \ + \ f^{-1}(n-2) & \mbox{ if } \  n > 2
\end{array}
\right.
\end{equation}

\smallskip

Taking the difference between expressions (\ref{eq:game-fill}) and (\ref{eq:game-empty}), we find that the costs of $f(n)$ and $f^{-1}(n)$ are equal!
\begin{eqnarray*}
f(n) \ - \ f^{-1}(n)
   & = & f(n-2) \ + \ 1 \ + \ f^{-1}(n-2) \ + \  f(n-1)   \\
   &    &  - \ f^{-1}(n-1) \ - \ f(n-2)  \ - \  1 \ - f^{-1}(n-2) \\
   & = & f(n-1) \ - \ f^{-1}(n-1) \\
   &    &  \hspace*{.25in} \cdots \\
   & = &  f(1) \ - \ f^{-1}(1) \\
   & = & 0
\end{eqnarray*}
\end{minipage}
}
\bigskip

We can dramatically simplify recurrence (\ref{eq:Token-cost-recurrence}) by focusing on the function
\[ g(n) \ \eqdef \ f(n) \ + \ f(n-1) \ \ \mbox{ for } \ n \geq 2 \]
instead of on $f$.  Elementary calculation based on (\ref{eq:Token-cost-recurrence}) shows that $g(n)$ satisfies the recurrence
\begin{equation}
\label{eq:g-Token-cost-recurrence}
g(n) \ = \ \left\{
\begin{array}{ll}
3 & \mbox{ if } \ n=2 \\
2 g(n-1) + 1 & \mbox{ if } \  n > 2
\end{array}
\right.
\end{equation}
We have, thereby, replaced the {\em bilinear} recurrence (\ref{eq:Token-cost-recurrence}) by the {\em (singly) linear} recurrence (\ref{eq:g-Token-cost-recurrence}).  We learned in
Section~\ref{sec:geometric-sums}---see Proposition~\ref{thm:sum-finite-geometric-series}---how to evaluate geometric summations that solve recurrences such as (\ref{eq:g-Token-cost-recurrence}).  In our case, we find that
\begin{equation}
\label{eq:VALUE-g-Token-cost}
g(n) \ \ = \ \ 2^{n-1} \ + \ 2^{n-2} \ + \cdots + \ 2^2 \ + \ 2 \ + \ 1 \ \ = \ \ 2^{n} -1
\end{equation}

\smallskip

We can now return to evaluating $f(n)$ via recurrence (\ref{eq:Token-cost-recurrence}), in the light of our analysis of $g(n)$ in recurrences (\ref{eq:g-Token-cost-recurrence}) and (\ref{eq:VALUE-g-Token-cost}).  We find that 
\begin{equation}
\label{eq:f-Token-cost-recurrence}
f(n) \ = \ \left\{
\begin{array}{ll}
1 & \mbox{ if } \ n=1 \\
g(n) - f(n-1) \ \ = \ \
\left(2^{n} -1\right) - f(n-1) & \mbox{ if } \ n>1
\end{array}
\right.
\end{equation}
We begin to solve the {\em singly} linear recurrence (\ref{eq:f-Token-cost-recurrence}) for $f(n)$ using the strategy we developed in Section~\ref{sec:geometric-sums}.  We expand the recurrence in order to discern its pattern and then analyze the summation that the pattern leads to.  In this case, we observe:
\begin{eqnarray*}
f(n) & = & 2^{n} - 2^{n-1} + f(n-2) + 1 -1 \\
     & = & 2^{n} - 2^{n-1} + 2^{n-2} - f(n-3) -1 \\
     & = & 2^{n} - 2^{n-1} + 2^{n-2} - 2^{n-3} + f(n-4) +1-1 \\
     &    & \hspace*{.35in}  \vdots
\end{eqnarray*}
What we observe emerging---an inviting induction for the reader lurks in those words---is a geometric summation of powers of $2$, with adjacent terms {\em alternating} in sign; the terminal units, $\pm 1$, cancel after each pair of steps.  We must be careful, though, because
the numbers of terms in the summations differ based on the parity of $n$: when $n$ is even, the last term is $0$; when $n$ is odd, the last term is $-1$.

\smallskip

We have now reached the {\em penultimate} step in finding the value of $f(n)$; specifically, we have derived the following parity-specified summations.
\begin{eqnarray}
\label{eq:EVEN-f-sum}
\mbox{For even values of } \ n: \ \ \
f(n) & = &
\sum_{k=1}^n \ (-1)^{k} \ 2^{k} \\
\label{eq:ODD-f-sum}
\mbox{For odd values of } \ n: \ \ \ \
f(n) & = &
\sum_{k=0}^n \ (-1)^{k+1} \ 2^{k}
\end{eqnarray}
Solving these summations for $f(n)$ requires a moderate bit of mathematical dexterity.  For pedagogical reasons, we illustrate two quite distinct approaches for determining the value of
$f(n)$ for the case of odd $n$:   We want to expose the reader to the quite-different intuitions that each approach elicits.  We shall then derive the value of $f(n)$ for the case of even $n$ from the value for the case of odd $n$.

\bigskip

\noindent {\it An algebraic approach for the case of odd $n$}.
We look in detail at summation (\ref{eq:ODD-f-sum}), which specifies $f(n)$ when $n$ is odd, and we invoke algebraic manipulation to determine the value of $f(n)$ in this case.

In the following chain of equalities, we: gather the positive and negative terms in summation (\ref{eq:ODD-f-sum}) [line 1 in the chain], perform some elementary manipulations on the result [lines 2 and 3 in the chain], and then invoke Proposition~\ref{thm:sum-finite-geometric-series} [line 4 in the chain, which evaluates the resulting geometric summation].   We
thereby find that, for odd values of $n$:
\begin{eqnarray*}
\label{eq:ODD-soln-f-sum}
f(n)
  & = &
\left(2^{n} \ + \ 2^{n-2} \ + \cdots + \ 2 \right) \ - \
  \left(2^{n-1} \ + \ 2^{n-3} \ + \cdots + \ 1 \right) \\
  & = &
2^{n-1} \ + \ 2^{n-3} \ + \cdots + \ 1  \\
  & = &
2^{n-1} \cdot \left( 1 \ + \ \frac{1}{4} \ + \ \frac{1}{16}  \ + \cdots + \ \frac{1}{2^{n-1}} \right) \\
  & = &  
2^{n-1} \cdot \left( 1 \ + \ \frac{1}{4} \ + \ \frac{1}{16}  \ + \cdots + \ \frac{1}{4^{(n-1)/2}} \right) \\
  & = & 
 2^{n-1} \cdot \frac{4}{3} \cdot \left( 1 \ - \  \left( \frac{1}{4} \right)^{(n+1)/2} \right) \\
   & = & 
\frac{ 2^{n+1} }{3} \cdot \left( 1 \ - \  \frac{1}{2^{n+1}} \right) \\
  & = & 
\frac{1}{3} \left(2^{n+1} -  \ 1 \right) \\
\end{eqnarray*}

\bigskip

\noindent {\it A geometric approach for the case of odd $n$}.
We begin again by looking again at summation (\ref{eq:ODD-f-sum}).  Then, noting that $2^{n-1}$ is a perfect square whenever $n$ is odd, we set out to represent $f(n)$ as the aggregated area of a shrinking sequence of squares, of successive dimensions
\[ 2^{(n-1)/2} \times 2^{(n-1)/2}, \ \ 2^{(n-3)/2} \times 2^{(n-3)/2},
\ \ 2^{(n-5)/2} \times 2^{(n-5)/2}, \
\ldots, \ \  1 \times 1
\]
Fig.~\ref{fig:alternatePowers2odd} depicts such a representation of $F(7) = 64+16+4+1 = 85$.
\begin{figure} [htb]
\begin{center}
        \includegraphics[scale=0.35]{FiguresMaths/alternatePowers2initOdd.png}
\caption{A representation of summation (\ref{eq:ODD-f-sum}) for the case $n=7$}
        \label{fig:alternatePowers2odd}
\end{center}
\end{figure}
To facilitate our upcoming manipulation of the configuration depicted in the figure, let us refer to the configuration as {\it the cascade of squares determined by $f(n)$}.   Note that, because each cascade is associated with an odd value of $n$, the smallest square in the cascade (at the far right in the figure) is the unit-side square, of dimensions $1 \times 1$; hence, it contributes $+1$ to the aggregate area of the cascade.

\smallskip

We can now use a geometric construction to evaluate $f(n)$ on an arbitrary odd argument $n$.  We take three copies of the cascade in Fig.~\ref{fig:alternatePowers2odd} and we manipulate the copies into the form is depicted in Fig.~\ref{fig:alternatePowers2finalOdd}.  
\begin{figure} [htb]
\begin{center}
        \includegraphics[scale=0.3]{FiguresMaths/alternatePowers2odd.png}
\caption{Evaluating $f(n)$ for odd $n$ by ``almost'' filling a large square}
        \label{fig:alternatePowers2finalOdd}
\end{center}
\end{figure}
In detail:
\begin{enumerate}
\item
We choose one of the three copies as the ``anchor'' of the construction.  We position it in space so that it serves as the upper white cascade in Fig.~\ref{fig:alternatePowers2finalOdd}.
\medskip\item
We then take a second copy, flip it across the horizontal axis, and abut the top edge of its largest square with the bottom edge of the largest square in the anchor cascade.  It then becomes the lower white cascade in Fig.~\ref{fig:alternatePowers2finalOdd}.

\smallskip

Note that, importantly, the abutted white cascades fit into a $2^{(n+1)/2} \times 2^{(n+1)/2}$ square.

\bigskip

\noindent \fbox{
\begin{minipage}{0.96\textwidth}
{\bf Explanatory note}.

\smallskip

All of our observations about figures fitting within other figures are verified by direct calculations.  These calculations are not too hard because all squares have side-dimensions that are powers of $2$.
\end{minipage}
}

\bigskip

Indeed, the top edge of the top white cascade and the bottom edge of the bottom white cascade lie, respectively, along the top and bottom edges of the $2^{(n+1)/2} \times 2^{(n+1)/2}$ square.  {\em However}, the cascades' edges are $1$ unit shorter than the edges of the big square; i.e., they both have length
\[ 2^{(n-1)/2} \ + \ 2^{(n-3)/2} \ + \ 2^{(n-5)/2} \ + \cdots + \ 1 \ = \ 2^{(n+1)/2} \ - 1 \]

\medskip\item
Finally, we take the third copy, color it grey, and nest it into the abutting white cascades in the following way.
  \begin{enumerate}
  \item
Take the biggest square in the grey cascade and nest it against the abutted biggest squares in the paired white cascades, in the manner depicted in Fig.~\ref{fig:alternatePowers2finalOdd}.  Note that the nest places one half of its biggest grey square abutting the biggest white square of the top white cascade and one half abutting the biggest white square of the bottom white cascade.  Observe (from Fig.~\ref{fig:alternatePowers2finalOdd}) that the resulting configuration fits within the $2^{(n+1)/2} \times 2^{(n+1)/2}$ square, and that the fit is {\em exact} along the left and right edges, which are shared by the abutting white cascades and the big square.

  \medskip\item
For all of the other grey squares, in decreasing order of size: We bisect---i.e., cut exactly in half---each square along its equator, and we nest the resulting two halves of that square symmetrically within the abutting white cascades, in the manner depicted in Fig.~\ref{fig:alternatePowers2finalOdd}.  Once again, we observe that the resulting configuration fits within the $2^{(n+1)/2} \times 2^{(n+1)/2}$ square, and that the fit is {\em exact} along the
left and right edges, which are shared by the abutting white cascades and the big square.

\smallskip

The placement of the bisected squares from the grey cascade leaves two small {\em empty} regions within the $2^{(n+1)/2} \times 2^{(n+1)/2}$ square.  The empty regions each have area $1/2$, because they are created by the ``inadequate'' placement of the bisected unit-side
square from the grey cascade; the empty regions appear at the top right and bottom right corners of the $2^{(n+1)/2} \times 2^{(n+1)/2}$ square.
  \end{enumerate}
\end{enumerate}

Once we have completed the described construction of the composite object depicted in Fig.~\ref{fig:alternatePowers2finalOdd}, we calculate that the combined areas of the three cascades is one unit less than the area of the $2^{(n+1)/2} \times 2^{(n+1)/2}$ square (which, of course, has area $2^{n+1}$).  We have thus shown geometrically that $3 f(n)+1 \ = \ 2^{n+1}$, which {\em (of course!)}~agrees with the value derived algebraically in
(\ref{eq:ODD-soln-f-sum}).

\bigskip

We immediately derive the expression for even $n$ using the definition of $g(n)$:
\begin{eqnarray*}
f(n) & = & 2^n \ - \ 1 \ - \ f(n-1) \ \ \ \mbox{ for } \ n \geq 2 \\
       & = & 2^n -1 - \frac{1}{3} \left( 2^{n} - 1 \right) \\
       & = & 2^n \left( 1 - \frac{1}{3} \right) - 1 +  \frac{1}{3} \\
       & = &  \frac{1}{3} \left(2^{n+1} - 2 \right)
\end{eqnarray*}
This completes the proof.  \qed
\end{proof}

\ignore{************
\subsubsection{Another property dealing with squares}

We will show the following property by two different methods

\noindent \textbf{Property.} 
\label{prop:FiboEmbedded}
$F(n+2)^2 = 4.F(n).F(n+1) + F(n-1)^2$ for $n \geq 2$.

The geometrical proof is obtained as depicted in Fig.~\ref{fig:fibosquareembedded} for computing $F_{n+2}^2$.

\begin{figure}[htb]
\begin{center}
        \includegraphics[scale=0.5]{FiguresMaths//FiboSquares}
        \caption{Geometric interpretation for computing $F_{n+2}^2$.}
        \label{fig:fibosquareembedded}
\end{center}
\end{figure}

Let remark that this figure might be adapted to show several properties using various decompositions of the squares and rectangles.

Another proof directly uses the definition of the Fibonacci numbers:

%$F_{n+1} + F_{n}$

$F(n+2)^2 = (F(n+1) + F(n))^2 $

$= F(n+1)^2+2.F(n+1).F(n)+F_{n}^2$

$= 4.F(n+1).F(n) - 2.F(n+1).F(n) + F(n+1)^2 + F(n)^2$

$= 4.F(n+1).F(n) + (F(n+1) - F(n))^2$

Again, using the definition of $F(n+1)$ into the square, we get the expected result:

$F(n+2)^2 = 4.FR(n+1).F(n) + F(n-1)^2$
***********}

\ignore{********
{\Arny This is another one we should discuss.  As with the section
  ``Another Identity'', Cassini's Identity does not strike me as
  ``pretty'' as the ``Consecutive products'', and the proof does not
  open the way to much new methodology.  I am troubled by Carroll's
  Puzzle because its resolution builds on principles that we do not
  cover anywhere.  Since this is not a true paradox, this material
  does not belong in that section.}

{\Denis Right, put this as an exercice. }

{\Arny Both of my preceding comments build on the question, Why should
  we include this material?  Obviously, when new techniques are
  involved, or when new, highly applicable, concepts are revealed,
  then the material should be included.  In other situations, I am
  just pulled by my gut feeling.  Should we discuss?}
**************}


\ignore{**************
\subsection{$\oplus$ Cassini's Identity}
\label{sec:Cassini}
\index{Fibonacci number/sequence!Cassini's Identity}


\noindent \textbf{Property. (Cassini's identity)} 
\label{prop:cassini}
$F(n-1).F(n+1) = F(n)^2 + (-1)^{n+1}$ for $n \geq 1$.


The proof by induction is as follows:

\begin{itemize}
\item 
The \textbf{basis case} is straightforward since $F(0).F(2) = 2$ and $F(1)^2 +1 = 2$.

\medskip\item
The \textbf{induction step} is proved assuming the Cassini's identity holds at rank $n$.

Apply the definition of $F(n+2)$:
 
$F(n).F(n+2) = F(n) (F(n+1)+F(n)) = F(n)^2 + F(n).F(n+1)$

Replace the last term using the recurrence hypothesis:

$F(n)^2 = F(n-1).F(n+1) - (-1)^{n+1} =F(n-1).F(n+1) + (-1)^{n+2} $

Thus,
$F(n).F(n+2) = F(n).F(n+1) + F(n-1).F(n+1) + (-1)^{n+2} = F(n+1) (F(n) + F(n-1)) + (-1)^{n+2}$ 

Apply again the definition of Fibonacci sequence $F(n) + F(n-1) = F(n+1)$, we obtain:

$F(n).F(n+2) = F(n+1)^2 + (-1)^{n+2}$
\end{itemize}


The previous result (Cassini's identity) can be used for a geometrical paradox (one of the favorite puzzle of Lewis Carroll).
Consider a chess board and cut it into 4 pieces as shown in figure~\ref{paradox}, then reassemble them into a rectangle.
%Interpret this paradox.
%
\begin{figure}[htb]
\begin{center}
\label{paradox}
       \includegraphics[scale=0.4]{FiguresMaths//FiboParadox.png}
              \caption{Construction of the rectangle after splitting the $8 \times 8$ square
              in two right $8$ by $3$ triangles and two polytopes.}
        \label{fig:FiboParadox}
\end{center}
\end{figure}

The surface of the square is $F(n)^2$ while the rectangle is $F(n+1).F(n-1)$.
In Fig.~\ref{fig:FiboParadox}, the Cassini identity is applied for $n=5$, $F(5)=8$. 
On one side, we obtain a surface of $8 \times 8 = 64$, but $13 \times 5 = 65$ on the other side!
What's wrong?

The paradox comes from the wrong representation of the diagonal of the rectangle which does not coincide with the hypothenuse
of the right triangles of sides $F(n+1)$ and $F(n-1)$.
In other words, it always remains (for any $n$) an empty space (corresponding to the unit size of the basic square of the chess board).
The greater $n$, the better the paradox because the deformation of the surface of this basic square becomes more tiny. 
***********************}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Exercises: Chapter 9}

Throughout the text, we mark each exercise with 0 or 1 or 2 occurrences of the symbol $\oplus$, as a rough gauge of its level of challenge.  The 0-$\oplus$ exercises should be accessible by just reviewing the text.  We provide {\em hints} for the 1-$\oplus$ exercises; Chapter~\ref{ch:Exercises} provides {\em solutions} for the 2-$\oplus$ exercises.  Additionally, we begin each exercise with a brief explanation of its anticipated value to the reader.

\begin{enumerate}
\item
{\bf Verifying an empirically observed pattern}

{\sc Lesson:} We have advocated expanding a recurrence to gain intuition regarding its growth pattern.  Of course, then one must verify one's observation.

\smallskip

{\em Verify the segment of recurrence (\ref{eq:Lin-Recur:expand}) that is ``hidden behind" the vertical dots.} 

\medskip\item
{\bf Completing the proof of the {\em general} version of the Master Theorem}

{\sc Lesson:} Practice in combining snippets of proofs.

\smallskip

%{\Arny. I corrected embedded quotation marks in the next paragraph.  The CE seems to have some problem with the reference to ``general recurrence (\ref{eq:Lin-Recur:general}) " -- but he does not explain what his problem is.  Am I missing something?}

We noted in the text that ``solving the more general recurrence (\ref{eq:Lin-Recur:general}) requires only augmenting the solution to the simple recurrence (\ref{eq:Lin-Recur:basic}) by `appending' to the simple solution a geometric summation whose base is the ratio $a/b$".

{\em Fill in the details of this observation.}

\medskip\item
{\bf An unusual comparison of automobile brands.}

{\sc Lessons:} Enhance facility with recurrences and asymptotics

\smallskip

The logos of two German automakers, {\sc Mercedes}$^{\mbox{\tiny\sc tm}}$ and BMW$^{\mbox{\tiny\sc tm}}$ suggest a (frivolous) game whose analysis can enhance one's understanding of both recurrences and asymptotics.  The game is designed around the fact that the {\sc Mercedes}$^{\mbox{\tiny\sc tm}}$ logo is a {\em trisection} of a circle, while the BMW$^{\mbox{\tiny\sc tm}}$ logo is a {\em quadrisection} of a circle.  
\begin{figure}[htb]
\begin{center}
        \includegraphics[scale=0.3]{FiguresMaths/AutomotiveBrands.png}
\end{center}
\caption{Idealized renditions of the logos on {\sc Mercedes}$^{\mbox{\tiny\sc tm}}$ (left) and BMW$^{\mbox{\tiny\sc tm}}$ (right) automobiles}
\label{fig:auto-logos}
\end{figure}
The single-player {\it Logo game} proceeds as follows.  

\smallskip

Reflecting the fact that the {\sc Mercedes}$^{\mbox{\tiny\sc tm}}$ logo partitions the circle into {\em three} wedges, while the BMW$^{\mbox{\tiny\sc tm}}$ logo partitions the circle into {\em four} wedges, we assign the player---who, note, has not yet acted---with the initial scores
\[ M(0) \ = \ 3 \ \ \ \ \ \mbox{ and } \ \ \ \ \ B(0) = 4 \] 
and we designate the logo-circles in Fig.~\ref{fig:auto-logos} as the {\em stage-$0$} logo-circles.   {\em Note that it is the {\em number} of wedges in each logo-circle that interests us, not the sizes of the wedges}.

\smallskip

The player now becomes active---

\medskip

For each positive integer $k$, the player begins at the northernmost point of each stage-$(k-1)$ logo-circle and circumnavigates the circle in a clockwise sense.  In the course of this circumnavigation, the player {\em bisects every second wedge} that she encounters.  When the player regains the northernmost point of the two logo-circles, the numbers of wedges at that moment is recorded as the score at that moment: at stage $k$ this has the form of the pair $\langle M(k), \ B(k) \rangle$. 

\medskip

{\em Prove the following assertions about the described game.
\begin{enumerate}
\item
For each $n \in \N^+$,
\[ M(n) \ = \ B(n-1) \]

\medskip\item
For each $n \in \N^+$,
\begin{equation}
\label{eq:BMWrecurrence}
B(n) \ = \ B(n-1) \ + \ \left\lfloor {1 \over 2} B(n-1) \right\rfloor 
\end{equation}

\medskip\item
$\oplus$ The asymptotic behavior of $B(n)$ is given by
\[ B(n) \ = \ \left({3 \over 2}\right)^{O(n)} \]

\smallskip

{\em Hint}.  Solve the ``continuous" version of recurrence (\ref{eq:BMWrecurrence})
for $B(n)$, which is obtained by removing the floors in (\ref{eq:BMWrecurrence}).  Then use asymptotic reasoning to complete the proof.
\end{enumerate}
}

\medskip\item
{\bf Karatsuba multiplication} 

\index{Karatsuba multiplication} \index{Karatsuba, Anatoly} 

{\sc Lesson:}
Use the Master Theorem for Linear Recurrences (Theorem~\ref{thm:master-thm-genl}) to analyze a recursive algorithm

\smallskip

Say that you are given two $n$-bit integers, in terms of their base-$2$ numerals: 
\[ A \ = \ a_{n-1} a_{n-2} \cdots a_0 \ \ \ \ \mbox{ and } \ \ \ \ B \ = \ b_{n-1} b_{n-2} \cdots b_0 \]
The classical elementary-school method for computing the product of $A$ and $B$ computes the $n$ partial products:
\[ (a_{n-1} a_{n-2} \cdots a_0) \times b_i 2^i \]
and then sums these partial products.  This algorithm requires $\Theta(n^2)$ multiplications and a like number of additions.

\smallskip

Now, multiplications are more expensive than additions on standard computing platforms.  Therefore, when the common length $n$ of the numerals for $A$ and $B$ is {\em very} large, then one would be willing to perform somewhat more additions (while staying within the asymptotic class $\Theta(n^2)$) if, in compensation, one could save a significant number of multiplications.  Happily, such a tradeoff is, indeed, available, using an algorithm that is known as {\it Karatsuba multiplication}, after its author, Anatoly Karatsuba; see \cite{KaratsubaO62}.

\medskip

Karatsuba's algorithm builds upon the {\it divide-and-conquer} algorithmic paradigm, whereby a
problem {\bf P} is decomposed into disjoint, equal-``size"\footnote{The paradigm works for a large range of ``size" measures: time, space, \ldots.}~subproblems whose results are accumulated to solve {\bf P}.

\index{divide-and-conquer algorithmic paradigm}

\bigskip

\noindent \fbox{
\begin{minipage}{0.96\textwidth}
{\bf Explanatory note}.

\smallskip

\noindent {\it The Divide-and-Conquer Paradigm:}
\begin{enumerate}
\item
Decompose the size-$n$ problem {\bf P} into $p$ subproblems of size $n/p$ each.
\medskip\item
Solve the subproblems.

\smallskip

Typically, this recursively invokes the {\bf P}-solver---down to some threshold size, at which point base case(s) of the recursion govern the computation.

\medskip\item
Combine the solutions of the subproblems to craft a solution of {\bf P}.
\end{enumerate}

\smallskip

The time-cost of the recursive computation that solves {\bf P} is given by the recurrent expression
\[  T(n) \ = \ p \cdot T(n/p) + \kappa(n) + \kappa'(n) \] 
$\kappa(n)$ and $\kappa'(n)$ are, respectively, the costs of phases (a.) and (c.) of the paradigm.
\end{minipage}
}
\bigskip

\textit{Karatsuba's algorithm.}
Let us return to the problem of multiplying the $n$-bit numerals $A$ and $B$.  To simplify both notation and analysis, say that $n$ is a very large power of $2$, i.e., $n=2^k$ for some large $k \in \N^+$.

\smallskip

The algorithm breaks the numerals for $A$ and $B$ into pairs of half-size numerals:
\begin{eqnarray*}
A & = & A_1 \cdot 2^{n/2} \ + \ A_2 \ \ 
 \eqdef  \ \ (a_n \cdots a_{n/2+1})_2 \cdot 2^{n/2} \ + \ (a_{n/2} \cdots a_1)_2 \\
B & = & B_1 \cdot 2^{n/2} \ + \  B_2 \ \
  \eqdef  \ \ (b_n \cdots b_{n/2+1})_2 \cdot 2^{n/2} \ + \ (b_{n/2} \cdots b_1)_2
\end{eqnarray*}

After this decomposition, we have\footnote{To enhance legibility, we use both the centered dot ($\cdot$) and the multiplication sign ($\times$).}
\begin{equation}
\label{eq:karatsuba-normal}
A \times B \ = \ (A_1 \times B_1) \cdot 2^n \ + \  (A_1 \times B_2 \ + \ A_2 \times B_1) \cdot 2^{n/2} \ + \ (A_2 \times B_2)
\end{equation}
A recursion (on $n$) that is based on instantiating Eq.~(\ref{eq:karatsuba-normal}) employs {\em four} multiplications at this level.

\smallskip

The way that Karatsuba brought the cost of multiplying $A \times B$ below the obvious measure of $\Theta(n^2)$ multiplications was to observe the following.  If one defines
\[ C \ \eqdef \ (A_1 - A_2) \times (B_2 - B_1) \]
then
\begin{eqnarray*}
A \times B & = & (A_1 \times B_1) \cdot 2^n \ + \ (A_2 \times B_2) \\
                 &    & + \ \big(C \ + \ (A_1 \times B_1) \ + \ (A_2 \times B_2) \big) \cdot 2^{n/2}
\end{eqnarray*}

{\em One thereby executes this level of the recursion that computes $A \times B$ using only {\em three} multiplications, rather than the four multiplications in Eq.~(\ref{eq:karatsuba-normal}).}  (The few more additions are often a beneficial cost-tradeoff.)

\medskip

{\em Prove the following assertions.}
\begin{enumerate}
\item
$\oplus$
{\em A recursion (on $n$) that is based on instantiating Eq.~(\ref{eq:karatsuba-normal}) computes the product $A \times B$ using $\Theta(n^2)$ multiplications.}

\medskip\item
$\oplus \oplus$
{\em A recursion (on $n$) that is based on Karatsuba's algorithm computes the product $A \times B$ using {\em asymptotically fewer than} $\Theta(n^2)$ multiplications.}

\smallskip

Your argument should find a (real) number $\alpha < 2$ such that Karatsuba's algorithm computes the product $A \times B$ using $\Theta(n^\alpha)$ multiplications.
\end{enumerate}

\medskip\item
{\bf Binomial coefficients and Pascal's Triangle}

{\sc Lessons:}
Practice with induction and intuition about binomial coefficients

\smallskip

{\em  Prove the following assertions, which refer to Fig.~\ref{fig:pascal-triangle}.} (The first assertion is Proposition~\ref{thm:pascal-binom}.)
  \begin{enumerate}
  \item
{\em For all $n,k$, the entry at (row $n$, column $k$) of the Triangle is $\displaystyle {n \choose k}$.}
  
  \medskip\item
{\em The successive rows of the Triangle sum to the successive powers of $2$.}

  \medskip\item
{\em The first element of every row is $1$.}

  \medskip\item
{\em The successive elements of column $2$ of the Triangle are the successive integers.}

  \medskip\item
{\em The successive elements of column $3$ of the Triangle are the successive triangular numbers, $\Delta_k$.}

  \medskip\item
{\em The successive elements of column $4$ of the Triangle are the successive tetrahedral numbers, $\widehat{\Theta}_k$.}
  
  \medskip\item
{\em Build on Figs.~\ref{fig:binomialCoeff1}--\ref{fig:binomialCoeff3} to generate an alternative proof of the summation formula for binomial coefficients.}
  \end{enumerate}

\medskip\item
{\bf Some details of the Token Game of Section ~\ref{sec:TokenGame}}

{\sc Lesson:}  The mental calisthenics of analyzing frivolous games often develop the muscles needed to tackle ``real" problems.

\smallskip

{\em Verify for small values of $n$ that the sequence of operations that empties the bank is the reverse of the sequence of operations that fills the bank---the first step becomes the last step, the second step becomes the second-to-last, and so on.}
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%

\ignore{**************
\subsection{Computing Fibonacci Numbers Fast}
\label{sec:FastFibo}

\noindent \textit{The aim.} 
Showing a new computational scheme for computing the Fibonacci numbers.

Notice that it is generic and related to the scheme of fast exponentiation.
\medskip


\noindent \textit{The problem.} 
Verify the following expression and develop an argument for its interest.

$F(2n) = F(n)^2 + F(n-1)^2$

$F(2n+1) = (2.F(n-1) + F(n)).F(n)$
\medskip

\noindent \textit{Hint.}
The proof of the first part is by induction
while a direct application to the definition of Fibonacci numbers allows to solve the second part..
\medskip


\noindent \textit{Lesson learned.}
Any Fibonacci number $F(n)$ can be computed very fast in $log_2 (n)$ steps.


\subsection{Cassini's Identity}

\noindent \textit{The aim.}
Prove a classical identity involving Fibonacci numbers, which is a nice example of proof by recurrence.
\medskip

\noindent \textit{The problem.}
Prove the following expression:

$F(n-1).F(n+1) = F(n)^2 + (-1)^{n+1}$ for $n \geq 1$
\medskip

%Let check the expression on the first ranks:
%
%$n=1$, $F(0).F(2) = F(1)^2 +1 = 2$
%
%$n=2$, $F(1).F(3) = F(2)^2 -1 = 3$
%
%$n=3$, $F(2).F(4) = F(3)^2 +1 = 10$
%
%$n=4$, $F(3).F(5) = F(4)^2 -1 = 24$
%
%...
%\medskip

\noindent \textit{Hint.}
The proof is by induction.
\medskip

\noindent \textit{Lesson learned.}
This is a classical relation that is interesting from a cultural perspective.
It also shows a clear example of solving recurrence equation. 
A nice variant is to ask to establish this identity (looking at the small values of $n$).


\subsection{Lucas Numbers} 

\noindent \textit{The aim.}
Fibonacci progression is the most popular and the most simple definition of Lucas numbers.
\medskip

\textbf{Definition.}
Given the two starting numbers $L(0) = 1$ and $L(1) = 3$, 
the other Lucas numbers are obtained by the same progression as Fibonacci: 

$L(n+1) = L(n)+L(n-1)$.
\medskip

%In order to gain intuition on this problem, let us compute the first ranks in regard to the classical Fibonacci numbers:
%\begin{figure}[htb]
%\[
%\begin{array}{c||r|r|r|r|r|r|r|r|r|r|r}
%{\displaystyle n } & k=0 & k=1 & k=2 & k=3 & k=4 & k=5 &
%k=6 & k=7 & k=8 & k=9 & \ldots \\
%\hline
%F(n) & 1 & 1 &  2  &  3  &   5  &   8  &  13  &  21  & 34  & 55  & \ldots \\
%\hline
%L(n) & 1 & 3 &  4 &  7  &  11  &  18  &  29 & 47  & 76  & 123 & \ldots \\
%\hline
%\end{array}
%\] 
%\caption{Correspondence between Fibonacci and Lucas numbers.}
%\label{fig:fiboLucas}
%\end{figure}
%%
%%n: $~~~~0, 1, 2, 3, ~4, ~5, ~6, ~7, ~8, ~~9, ...$
%%
%%F(n): $1, 1, 2, 3, ~5, ~8, 13, 21, 34, ~55, ...$
%%
%%L(n): $1, 3, 4, 7, 11, 18, 29, 47, 76, 123, ...$
%\medskip
%
%%
%%There are strong links with Fibonacci numbers.
%%In particular, we established before that
%%\bigskip
%%
%%$F(n+2) = 1+ \sum_{k=0}^{n} F(k)$. 
%%\bigskip
%%
%%We have similarly: $L(n+2) = 1+ \sum_{k=-1}^{n} L(k)$ since the basic step of the induction is still valid: 
%%
%%$L(2) = L(-1 )+L(0) +1 = 2+1+1 = 4$.
%%%Actually, it will be true for all the progressions where $u_1=1$.
%

\noindent \textit{The problem.}
Prove the following expression:

$F(k-1).L(n) = F(n+k)+ (-1)^{k-1}F(n-k)$ for $k \leq n$
\bigskip

\noindent \textit{Hint.} 
There are two integers involved here ($k$ and $n$).
Let us study the expression step by step for successive values of $k$.
\medskip

% Starting smoothly with $k=1$
%
%We can easily show by induction on $n$ that the Lucas number of order $n$ is the sum of two Fibonacci numbers:
%
%$L(n) = F(n-1)+F(n+1)$ for $n \geq 1$
%\medskip
%
%%Let check this property on the first ranks:
%%
%%$n=2$, $L(2) = F(1)+F(3) = 1 + 3 = 4$
%%
%%$n=3$, $L(3) = F(2)+F(4) = 2 + 5 = 7$
%%
%%$n=4$, $L(4) = F(3)+F(5) = 3 + 8 = 11$
%%
%%$n=5$, $L(5) = F(4)+F(6) = 5 + 13 = 18$
%%
%
%The basis case, corresponding to for $n=1$) is true since $L(1) = 3 = F(2) + F(0) = 2+1$.
%
%Let assume for proving the induction step that the property holds at all ranks $k \leq n$ and compute $L(n+1)$:
%
%Apply the definition of Lucas' numbers: $L(n+1) = L(n)+L(n-1)$
%
%Apply the induction hypothesis on both terms of the right hand side:
%
% $L(n+1) = F(n+1)+F(n-1)+F(n)+F(n-2)$
%
%Apply now the definition of Fibonacci numbers for $F(n+1) + F(n) = F(n+2)$  and $F(n-1) + F(n-2) = F(n)$
%
%Replace them in the previous expression:
%
%$L(n+1) = F(n+2)+F(n)$
%
%which concludes the proof.

Extension:
Using a similar approach, we obtain $L(n) = F(n+2)-F(n-2)$. 
What happens if we generalize? Easy calculations lead to the following results:
\medskip

$2.L(n) = F(n+3) + F(n-3) $

%Proposition.
%
%$2.L(n) = F(n+3)+F(n-3)$
%\bigskip
%
%Proof.
%We start from $L(n) = F(n+2)-F(n-2)$
%
%$F(n+2) = F(n+3) - F(n+1)$ and $F(n-2) = F(n-1) - F(n-3)$
%
%$L(n) = F(n+3) - (F(n+1) + F(n-1)) + F(n-3)$
%
%$2.L(n) = F(n+3) + F(n-3)$
%
%
%\medskip\item Extension 2
%
%Go to the next step using the same technique:
%\medskip
%
%
%
%$= F(n+4) - F(n+2) + F(n-2) - F(n-4)$
%\medskip
%
%$3.L(n) = F(n+4) - F(n-4)$
%
%$5.L(n) = F(n+5) + F(n-5)$
%\medskip
% 
%As $2, 3, 5$ are successive Fibonacci numbers, this gives us the intuition of the general case:
%
%$F(k-1).L(n) = F(n+k) + (-1)^{k-1}F(n-k)$ for $k \leq n$
%\medskip
%
%which is proved (again) as follows by induction assuming the expression holds at rank up to $k$.
%
%The basis case is straightforward (see case $k=1$).
%
%Compute $F((k+1)-1).L(n)$ and apply the definition of Fibonacci number $F((k+1)-1) = F(k-1) + F(k-2)$
%
%$F(k).L(n) = F(k-1).L(n + F(k-2).L(n)$ and replace both last terms by using the induction hypothesis:
%
%$= F(n+k) + (-1)^{k-1}F(n-k) + F(n+k-1) + (-1)^{k-2}F(n-(k-1))$
%
%$= F(n+k) +  F(n+k-1) + (-1)^{k-1}(F(n-k) - F(n-k+1))$
%
%The final result is obtained by applying twice the definition of the Fibonacci numbers.
%\medskip

\noindent \textit{Lesson learned.}
This exercice is a good example of the proof of a non straightforward recurrence which involves two integers.

\subsection{Solving a bilinear recurrence by a linear system}

\noindent \textit{The aim.}
Showing an alternative for solving bilinear recurrence.
\medskip

\noindent \textit{The problem.}
Determine the values of the successive terms $U_n$ defined by the following recurrence equation:

$U_{n} = \frac{1}{2}.U_{n-1} + \frac{1}{2}.U_{n+1}$

given $U_0 = 0$ and $U_N = 1$
\medskip

\noindent \textit{Hint}
Write the solution for small values of $n$

Write the successive steps of the recurrence as a linear system and solve it.
****************}
